<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ONI — Dupe Ranker</title>
<style>
/* --- Global Reset & Variables --- */
:root {
    --color-bg-dark: #0e1321;
    --color-bg-medium: #1b2135;
    --color-bg-light: #2a3552;
    --color-text-primary: #e5eaf0;
    --color-text-secondary: #9aa7b2;
    --color-accent-blue: #70d1ff;
    --color-accent-green: #3ee6b0;
    --color-accent-red: #ff7070;
    --font-family-primary: 'Arial', sans-serif;
}
* {
    box-sizing: border-box;
}
body {
    margin: 0;
    background: var(--color-bg-dark);
    color: var(--color-text-primary);
    font-family: var(--font-family-primary);
    display: flex;
    justify-content: center;
    padding: 20px;
    min-height: 100vh;
}
.app {
    width: 100%;
    max-width: 1200px;
}
h1 {
    color: var(--color-accent-blue);
    margin-top: 0;
}
h3 {
    border-bottom: 1px solid var(--color-bg-light);
    padding-bottom: 5px;
    margin-top: 25px;
}
/* --- Status Row --- */
.status-row {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    margin-bottom: 25px;
}
.pill {
    background: var(--color-bg-medium);
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: bold;
    color: var(--color-text-primary);
    display: flex;
    align-items: center;
    gap: 8px;
}
.pill > span {
    color: var(--color-accent-green);
}
/* --- Arena / Duel Area --- */
.arena {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-bottom: 20px;
}
.card {
    flex: 1;
    background: var(--color-bg-medium);
    border-radius: 12px;
    padding: 20px;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    min-height: 450px;
    max-width: 380px;
    border: 3px solid transparent;
    transition: all 0.3s ease;
}
.card.highlight-winner {
    border-color: var(--color-accent-green);
}
.card.highlight-loser {
    opacity: 0.5;
}
.dupe-img-container {
    width: 100%;
    max-width: 300px;
    padding: 10px;
    background: var(--color-bg-dark);
    border-radius: 8px;
    margin-bottom: 15px;
    flex-shrink: 0;
}
.dupe-img {
    width: 100%;
    height: auto;
    max-height: 280px;
    object-fit: contain;
    display: block;
}
.dupe-name {
    font-weight: 700;
    font-size: 1.2em;
    margin-bottom: 15px;
    color: var(--color-accent-blue);
    flex-grow: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}
.choose-btn {
    width: 100%;
    background: var(--color-bg-light);
    border: none;
    padding: 12px 16px;
    border-radius: 8px;
    color: var(--color-text-primary);
    font-weight: bold;
    font-size: 1.1em;
    cursor: pointer;
    transition: background 0.2s, transform 0.1s;
    text-transform: uppercase;
}
.choose-btn:hover:not(:disabled) {
    background: #39456c;
    transform: translateY(-2px);
}
.choose-btn:disabled {
    background: #1a2033;
    cursor: not-allowed;
    opacity: 0.6;
}
/* --- Controls and Progress --- */
.controls {
    display: flex;
    gap: 15px;
    align-items: center;
    margin-top: 10px;
    margin-bottom: 30px;
}
.controls button.small {
    background: var(--color-bg-light);
    border: none;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    color: var(--color-text-primary);
    font-weight: bold;
    transition: background 0.2s;
    flex-shrink: 0;
}
.controls button.small:hover:not(:disabled) {
    background: #39456c;
}
.controls button.small:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
.progress {
    flex: 1;
    height: 12px;
    background: var(--color-bg-medium);
    border-radius: 6px;
    overflow: hidden;
}
.progress > i {
    display: block;
    height: 100%;
    background: linear-gradient(90deg, var(--color-accent-green), var(--color-accent-blue));
    width: 0%;
    transition: width 0.3s ease-out;
}
/* --- Final Ranking --- */
.final-ranking {
    margin-top: 30px;
}
.rank-list {
    display: grid;
    gap: 10px;
    margin-top: 15px;
}
.rank-item {
    background: var(--color-bg-medium);
    border-radius: 8px;
    padding: 10px 15px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 1.1em;
    border-left: 5px solid var(--color-accent-blue);
}
.rank-item:nth-child(1) { border-left-color: gold; }
.rank-item:nth-child(2) { border-left-color: silver; }
.rank-item:nth-child(3) { border-left-color: #cd7f32; /* Bronze */ }

.rank-item-info {
    display: flex;
    align-items: center;
    gap: 15px;
}
.rank-item img {
    width: 40px;
    height: 40px;
    object-fit: contain;
    border-radius: 6px;
    background: var(--color-bg-dark);
    padding: 4px;
}
.rank-name-id {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}
.rank-filename {
    font-size: 0.8em;
    color: var(--color-text-secondary);
}
/* --- Log Area --- */
#logArea {
    margin-top: 20px;
    color: var(--color-text-secondary);
    font-size: 12px;
    max-height: 150px;
    overflow-y: auto;
    padding: 5px;
    border-top: 1px solid var(--color-bg-light);
}
#logArea > div:first-child {
    font-weight: bold;
    color: var(--color-text-primary);
}
</style>
</head>
<body>
<div class="app">
    <header>
      <h1>ONI — Dupe Ranker</h1>
      <div style="color:var(--color-text-secondary); font-size:14px; margin-bottom:25px;">Choose your preferred **Duplicant** in each pair to create a fully sorted list of your favorites.</div>
    </header>

  <div class="status-row">
    <div class="pill">Progress: <span id="progressText">0 / 0</span></div>
    <div class="pill">Total Dupes: <span id="totalDupes">0</span></div>
  </div>

  <div class="arena" id="arena">
    <div class="card" id="leftCard">
      <div class="dupe-img-container">
          <img id="leftImg" class="dupe-img" src="" alt="Left Duplicant">
      </div>
      <div class="dupe-name" id="leftName">...</div>
      <button class="choose-btn" id="leftBtn" data-side="left">Choose Left (←)</button>
    </div>

    <div class="card" id="rightCard">
      <div class="dupe-img-container">
          <img id="rightImg" class="dupe-img" src="" alt="Right Duplicant">
      </div>
      <div class="dupe-name" id="rightName">...</div>
      <button class="choose-btn" id="rightBtn" data-side="right">Choose Right (→)</button>
    </div>
  </div>

  <div class="controls">
    <div class="progress"><i id="progressBar"></i></div>
    <button class="small" id="undoBtn">Undo</button>
    <button class="small" id="restartBtn">Restart</button>
  </div>

  <div class="final-ranking" id="finalArea" hidden>
    <h3>Final Ranking</h3>
    <div class="rank-list" id="rankingList"></div>
  </div>

  <div id="logArea"></div>
</div>

<script>
/*
 * ONI Dupe Ranker - Merge Sort Implementation
 * This provides a more accurate ranking than the previous tournament model.
 */

const ALL = [
"abe","ada","amari","ari","ashkan","bahni","bubbles","burt","camilla","camille",
"catilina","chip","devon","edwirdo","ellie","frankie","freya","gizmo","gossman",
"harold","higsby","jean","joshua","leira","liam","marie","max","may","maya",
"meep","mi-ma","nails","nikola","nisbet","otto","pei","quinn","ren","rowan",
"ruby","sonyar","steela","steeve","stinky","travaldo","turner", "jorge"
];

// ---- state ----
let initialPool = ALL.map(n => n + ".png");
let history = []; // for undo
let totalComparisonsEstimate = 0;
let comparisonsDone = 0;

// Merge sort specific state
let sortStack = [];
let leftList = null;
let rightList = null;
let mergedResult = [];
let isFinished = false;

// --- DOM Elements ---
const leftImg = document.getElementById('leftImg');
const rightImg = document.getElementById('rightImg');
const leftName = document.getElementById('leftName');
const rightName = document.getElementById('rightName');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const leftCard = document.getElementById('leftCard');
const rightCard = document.getElementById('rightCard');

const progressText = document.getElementById('progressText');
const totalDupes = document.getElementById('totalDupes');
const logArea = document.getElementById('logArea');
const progressBar = document.getElementById('progressBar');
const restartBtn = document.getElementById('restartBtn');
const undoBtn = document.getElementById('undoBtn');
const finalArea = document.getElementById('finalArea');
const rankingList = document.getElementById('rankingList');

// --- Helpers ---
function basenameToLabel(fn){
    if (!fn) return '...';
    return fn.replace('.png','').replace(/-/g,' ').replace(/\b\w/g, c => c.toUpperCase());
}
function filenameOnly(fn){
    if (!fn) return '';
    return fn.replace('.png', '');
}
// *** THE FIX IS HERE ***
function imgPath(fn){ return 'images/' + fn; }

function shuffle(a){
    for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
}

// --- Sorting Logic ---

function startSort() {
    isFinished = false;
    history = [];
    comparisonsDone = 0;
    const shuffled = shuffle(initialPool.slice());
    
    const n = initialPool.length;
    totalComparisonsEstimate = Math.ceil(n * Math.log2(n) - n + 1);

    sortStack = shuffled.map(item => [item]);
    
    leftList = null;
    rightList = null;
    mergedResult = [];

    finalArea.hidden = true;
    rankingList.innerHTML = '';
    logArea.innerHTML = '';
    log(`Sorting started with ${n} Duplicants.`);
    undoBtn.disabled = true;

    processNextMergeStep();
}

function processNextMergeStep() {
    if (leftList && rightList) {
        if (leftList.length === 0) {
            mergedResult.push(...rightList);
            rightList = [];
            finishCurrentMerge();
            return;
        }
        if (rightList.length === 0) {
            mergedResult.push(...leftList);
            leftList = [];
            finishCurrentMerge();
            return;
        }
        if (leftList[0] === rightList[0]) {
            log(`CRITICAL: Duplicate item detected (${basenameToLabel(leftList[0])}). Auto-resolving.`);
            mergedResult.push(leftList.shift()); // just pick one and move on
            processNextMergeStep();
            return;
        }
        updateUI();
    } else {
        if (sortStack.length > 1) {
            leftList = sortStack.pop();
            rightList = sortStack.pop();
            mergedResult = [];
            log(`Merging a list of ${leftList.length} with a list of ${rightList.length}.`);
            processNextMergeStep();
        } else {
            isFinished = true;
            const finalRankedList = sortStack[0] || [];
            log("Sorting complete!");
            showFinal(finalRankedList);
        }
    }
}

function finishCurrentMerge() {
    log(`Merge finished. New sorted list has ${mergedResult.length} items.`);
    sortStack.push(mergedResult);
    leftList = null;
    rightList = null;
    mergedResult = [];
    undoBtn.disabled = true;
    processNextMergeStep();
}

function choose(side) {
    if (isFinished || !leftList || !rightList) return;

    const leftItem = leftList[0];
    const rightItem = rightList[0];
    let winner, loser;

    if (side === 'left') {
        winner = leftList.shift();
        loser = rightItem;
        mergedResult.push(winner);
        leftCard.classList.add('highlight-winner');
        rightCard.classList.add('highlight-loser');
    } else {
        winner = rightList.shift();
        loser = leftItem;
        mergedResult.push(winner);
        rightCard.classList.add('highlight-winner');
        leftCard.classList.add('highlight-loser');
    }
    
    history.push({
        type: 'compare',
        winner: winner,
        loser: loser,
        winnerOriginalList: (side === 'left' ? 'left' : 'right'),
        loserOriginalList: (side === 'left' ? 'right' : 'left'),
    });
    comparisonsDone++;

    leftBtn.disabled = rightBtn.disabled = true;

    setTimeout(() => {
        leftCard.classList.remove('highlight-winner', 'highlight-loser');
        rightCard.classList.remove('highlight-winner', 'highlight-loser');
        processNextMergeStep();
    }, 400);
}

function undo() {
    if (history.length === 0 || !leftList) {
        log("Nothing to undo or cannot undo at this stage.");
        return;
    }
    if (isFinished) {
        isFinished = false;
        finalArea.hidden = true;
        sortStack.push(mergedResult);
    }

    const lastAction = history.pop();
    if (lastAction.type === 'compare') {
        const { winner, winnerOriginalList } = lastAction;

        if(mergedResult.length > 0 && mergedResult[mergedResult.length - 1] === winner){
            mergedResult.pop();
        }
       
        if (winnerOriginalList === 'left') {
            leftList.unshift(winner);
        } else {
            rightList.unshift(winner);
        }

        comparisonsDone--;
        log(`Undo: Re-comparing ${basenameToLabel(winner)}.`);
        updateUI();
    }
    undoBtn.disabled = history.length === 0;
}


// --- UI and Display ---

function updateUI() {
    if (isFinished) {
        leftCard.style.opacity = 0;
        rightCard.style.opacity = 0;
        return;
    }
    undoBtn.disabled = history.length === 0;

    const leftItem = leftList[0];
    const rightItem = rightList[0];
    
    leftImg.src = imgPath(leftItem);
    leftImg.alt = basenameToLabel(leftItem);
    leftName.textContent = basenameToLabel(leftItem);
    leftBtn.textContent = `Choose ${basenameToLabel(leftItem)} (←)`;
    
    rightImg.src = imgPath(rightItem);
    rightImg.alt = basenameToLabel(rightItem);
    rightName.textContent = basenameToLabel(rightItem);
    rightBtn.textContent = `Choose ${basenameToLabel(rightItem)} (→)`;

    leftBtn.disabled = false;
    rightBtn.disabled = false;
    
    totalDupes.textContent = initialPool.length;
    progressText.textContent = `${comparisonsDone} / ~${totalComparisonsEstimate}`;
    const pct = totalComparisonsEstimate > 0 ? (comparisonsDone / totalComparisonsEstimate) * 100 : 0;
    progressBar.style.width = Math.min(100, pct) + '%';
}

function showFinal(finalRanking) {
    rankingList.innerHTML = '';
    finalArea.hidden = false;
    
    for(let i=0; i < finalRanking.length; i++){
        const fn = finalRanking[i];
        const label = basenameToLabel(fn);
        const item = document.createElement('div');
        item.className = 'rank-item';
        item.innerHTML = `
            <div class="rank-item-info">
                <div style="font-size:1.5em; width:30px;">#${i+1}</div>
                <img src="${imgPath(fn)}" alt="${label}">
                <div class="rank-name-id">
                    <strong>${label}</strong>
                    <span class="rank-filename">${filenameOnly(fn)}</span>
                </div>
            </div>
        `;
        rankingList.appendChild(item);
    }
    
    leftBtn.disabled = rightBtn.disabled = true;
    undoBtn.disabled = true;
    leftName.textContent = "Ranking Complete!";
    rightName.textContent = "";
    leftImg.src = "";
    rightImg.src = "";
}

function log(txt){
    const t = document.createElement('div');
    t.innerHTML = `[${new Date().toLocaleTimeString()}] ${txt}`;
    logArea.prepend(t);
}

// --- Event Listeners ---
leftBtn.addEventListener('click', () => choose('left'));
rightBtn.addEventListener('click', () => choose('right'));
restartBtn.addEventListener('click', () => {
    if(confirm("Restart the entire ranking process? This clears all progress.")) {
        startSort();
    }
});
undoBtn.addEventListener('click', () => undo());

document.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowLeft' && !leftBtn.disabled) {
        e.preventDefault();
        choose('left');
    }
    if(e.key === 'ArrowRight' && !rightBtn.disabled) {
        e.preventDefault();
        choose('right');
    }
});

// Kick things off :3
startSort();

</script>
</body>
</html>
