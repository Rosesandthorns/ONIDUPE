<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>O N I — Dupe Duelist</title>
<style>
  body {
    margin:0;
    background:#0e1321;
    color:#e5eaf0;
    font-family:Arial, sans-serif;
    display:flex;
    justify-content:center;
    padding:20px;
  }
  .app {
    width:100%;
    max-width:1000px;
  }
  .status-row {
    display:flex;
    gap:20px;
    flex-wrap:wrap;
    margin-bottom:20px;
  }
  .pill {
    background:#1b2135;
    padding:6px 12px;
    border-radius:12px;
    font-size:14px;
  }
  .arena {
    display:flex;
    justify-content:space-between;
    gap:20px;
    margin-bottom:20px;
  }
  .card {
    flex:1;
    background:#1a2033;
    border-radius:12px;
    padding:12px;
    text-align:center;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:space-between;
    min-height:400px;
  }
  .dupe-img {
    width:100%;
    max-width:280px;
    height:280px;
    object-fit:contain;
    background:#0d1222;
    border-radius:8px;
    margin-bottom:12px;
  }
  .dupe-name {
    font-weight:bold;
    margin-bottom:12px;
  }
  .choose-btn {
    background:#2a3552;
    border:none;
    padding:10px 16px;
    border-radius:8px;
    color:#e5eaf0;
    font-weight:bold;
    cursor:pointer;
    transition:background 0.2s;
  }
  .choose-btn:hover {
    background:#39456c;
  }
  .controls {
    display:flex;
    gap:12px;
    align-items:center;
    margin-top:16px;
  }
  button.small {
    background:#2a3552;
    border:none;
    padding:6px 10px;
    border-radius:6px;
    cursor:pointer;
    color:#e5eaf0;
  }
  .progress {
    flex:1;
    height:10px;
    background:#2a3552;
    border-radius:5px;
    overflow:hidden;
  }
  .progress > i {
    display:block;
    height:100%;
    background:linear-gradient(90deg,#3ee6b0,#70d1ff);
    width:0%;
  }
  .final-ranking {
    margin-top:24px;
  }
  .rank-list {
    display:grid;
    grid-template-columns:1fr auto;
    gap:8px;
    margin-top:12px;
  }
  .rank-item {
    background:#1b2135;
    border-radius:8px;
    padding:6px 10px;
    display:flex;
    align-items:center;
    gap:8px;
  }
  .rank-item img {
    width:36px;
    height:36px;
    object-fit:contain;
    border-radius:6px;
    background:#0d1222;
    padding:4px;
  }
</style>
</head>
<body>
<div class="app">
    <header>
      <h1>ONI — Dupe Duelist</h1>
      <div style="color:#9aa7b2; font-size:13px; margin-bottom:20px;">Choose which dupe you prefer in each face-off. Winners advance; losers are ranked.</div>
    </header>

  <div class="status-row">
    <div class="pill" id="roundBadge">Round: 1</div>
    <div class="pill" id="modeBadge">Mode: Pairing</div>
    <div class="pill" id="poolSize">Remaining: 0</div>
    <div class="pill" id="progressText">Comparisons: 0</div>
  </div>

  <div class="arena" id="arena">
    <div class="card" id="leftCard">
      <img id="leftImg" class="dupe-img" src="" alt="">
      <div class="dupe-name" id="leftName"></div>
      <button class="choose-btn" id="leftBtn">Choose Left</button>
    </div>

    <div class="card" id="rightCard">
      <img id="rightImg" class="dupe-img" src="" alt="">
      <div class="dupe-name" id="rightName"></div>
      <button class="choose-btn" id="rightBtn">Choose Right</button>
    </div>
  </div>

  <div class="controls">
    <div class="progress"><i id="progressBar"></i></div>
    <button class="small" id="undoBtn">Undo</button>
    <button class="small" id="restartBtn">Restart</button>
  </div>

  <div class="final-ranking" id="finalArea" hidden>
    <h3>Final Ranking</h3>
    <div class="rank-list" id="rankingList"></div>
  </div>

  <div style="margin-top:20px; color:#9aa7b2; font-size:12px;" id="logArea"></div>
</div>

<script>
/*
 ONI Dupe Duelist Logic - Completed Script
*/

const ALL = [
"abe","ada","amari","ari","ashkan","bahni","bubbles","burt","camilla","camille",
"catilina","chip","devon","edwirdo","ellie","frankie","freya","gizmo","gossman",
"harold","higsby","jean","joshua","leira","liam","marie","max","may","maya",
"meep","mi-ma","nails","nikola","nisbet","otto","pei","quinn","ren","rowan",
"ruby","sonyar","steela","steeve","stinky","travaldo","turner",
// Jorge is included here
"jorge"
];

// ---- state ----
let initialPool = ALL.map(n => n + ".png");
let roundNumber = 1;
let currentPool = [];      // pool for current round (filenames)
let nextPool = [];         // winners advancing to next round
let roundLosersUnordered = []; // losers in this round (unordered)
let orderedLosersAllRounds = []; // ordered losers appended after each round (from worst up)
let comparisonCount = 0;
let totalComparisonsEstimate = 0;
let mode = "pairing"; // 'pairing' or 'sortingLosers' or 'finished'
let pairQueue = []; // queue of pair comparisons for pairing mode
let sortingState = null; // state for interactive insertion-ranking of losers (object)
let history = []; // for undo — stack of actions {type, data}
let champion = null;

const leftImg = document.getElementById('leftImg');
const rightImg = document.getElementById('rightImg');
const leftName = document.getElementById('leftName');
const rightName = document.getElementById('rightName');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const roundBadge = document.getElementById('roundBadge');
const modeBadge = document.getElementById('modeBadge');
const poolSize = document.getElementById('poolSize');
const logArea = document.getElementById('logArea');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const restartBtn = document.getElementById('restartBtn');
const undoBtn = document.getElementById('undoBtn');
const finalArea = document.getElementById('finalArea');
const rankingList = document.getElementById('rankingList');

// helpers
function basenameToLabel(fn){
  return fn.replace('.png','').replace(/-/g,' ').replace(/\b\w/g, c => c.toUpperCase());
}
function imgPath(fn){ return 'images/' + fn; }

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

// build pair queue for single-elimination pairing
function buildPairQueueFor(pool){
  const q = [];
  const arr = pool.slice();
  shuffle(arr);
  while(arr.length >= 2){
    const a = arr.shift();
    const b = arr.shift();
    q.push([a,b]);
  }
  // if odd, last one gets bye (treated as auto-advance)
  if(arr.length === 1){
    q.push([arr.shift(), null]); // null signals bye
  }
  return q;
}

// insertion ranking generator: given a list of losers, generate interactive comparisons
function startSortingLosers(list){
  if(list.length === 0){
    sortingState = null;
    finishSortingLosers();
    return;
  }
  sortingState = {
    items: list.slice(),  
    ranked: [],
    currentItem: null,
    compareIndex: 0
  };
  mode = 'sortingLosers';
  modeBadge.textContent = 'Mode: Sorting losers';
  log("Sorting " + list.length + " loser(s) for Round " + roundNumber + ".");
  prepareNextSortingComparison();
}

function prepareNextSortingComparison(){
  if(!sortingState) return;
  if(sortingState.currentItem == null){
    // take next item
    sortingState.currentItem = sortingState.items.shift();
    sortingState.compareIndex = 0;
    // if ranked empty, insert immediately
    if(sortingState.ranked.length === 0){
      sortingState.ranked.push(sortingState.currentItem);
      history.push({type:'insert-loser', data:{item:sortingState.currentItem, pos:0}}); // for undo
      sortingState.currentItem = null;
      prepareNextSortingComparison();
      return;
    }
  }

  // if compareIndex >= ranked.length then append at end
  if(sortingState.compareIndex >= sortingState.ranked.length){
    sortingState.ranked.push(sortingState.currentItem);
    history.push({type:'insert-loser', data:{item:sortingState.currentItem, pos:sortingState.ranked.length-1}});
    sortingState.currentItem = null;
    prepareNextSortingComparison();
    return;
  }

  // otherwise, compare currentItem vs ranked[compareIndex]
  const a = sortingState.currentItem;
  const b = sortingState.ranked[sortingState.compareIndex];
  // queue this comparison for showing
  pairQueue = [[a,b]];
  updatePoolUI();
}

// after sorting completed:
function finishSortingLosers(){
  // append sorted losers for this round to global ordered losers
  if(sortingState && sortingState.ranked){
    orderedLosersAllRounds.push(...sortingState.ranked.slice()); // best of losers first
  }
  sortingState = null;
  // prepare next round
  roundNumber++;
  currentPool = nextPool.slice();
  nextPool = [];
  comparisonCount = 0;
  // if only one left, finished
  if(currentPool.length <= 1){
    if(currentPool.length === 1){
      champion = currentPool[0];
    }
    mode = 'finished';
    showFinal();
    return;
  }
  // else start next pairing round
  mode = 'pairing';
  pairQueue = buildPairQueueFor(currentPool);
  totalComparisonsEstimate = pairQueue.length;
  roundBadge.textContent = 'Round: ' + roundNumber;
  modeBadge.textContent = 'Mode: Pairing';
  poolSize.textContent = 'Remaining: ' + pairQueue.length;
  log("Starting Round " + roundNumber + " with " + currentPool.length + " dupes.");
  updatePoolUI();
}

// UI rendering for current pairQueue or sorting comparison
function updatePoolUI(){
  if(mode === 'pairing'){
    modeBadge.textContent = 'Mode: Pairing';
    roundBadge.textContent = 'Round: ' + roundNumber;
    poolSize.textContent = 'Remaining: ' + pairQueue.length;
    progressText.textContent = `Comparisons: ${comparisonCount}`;
    const pct = totalComparisonsEstimate ? Math.round((comparisonCount/totalComparisonsEstimate)*100) : 0;
    progressBar.style.width = pct + '%';
    if(pairQueue.length === 0){
      // begin sorting this round's losers
      mode = 'sortingLosers';
      modeBadge.textContent = 'Mode: Sorting losers';
      startSortingLosers(roundLosersUnordered);
      roundLosersUnordered = [];
      return;
    }
    const [a,b] = pairQueue[0];
    if(!b){
      // bye - auto advance
      showBye(a);
      return;
    }
    showPair(a,b);
  } else if(mode === 'sortingLosers'){
    modeBadge.textContent = 'Mode: Sorting losers';
    if(pairQueue.length === 0){
      if(sortingState && (sortingState.items.length > 0 || sortingState.currentItem != null)){
        prepareNextSortingComparison();
        return;
      } else {
        // done
        finishSortingLosers();
        return;
      }
    } else {
      const [a,b] = pairQueue[0];
      showPair(a,b);
    }
  } else if(mode === 'finished'){
    leftName.textContent = rightName.textContent = "Tournament complete";
    leftImg.src = rightImg.src = "";
    leftBtn.disabled = rightBtn.disabled = true;
    poolSize.textContent = 'Remaining: 0';
  }
}

// show a pair
function showPair(a,b){
  leftImg.src = imgPath(a);
  rightImg.src = imgPath(b);
  leftImg.alt = basenameToLabel(a);
  rightImg.alt = basenameToLabel(b);
  leftName.textContent = basenameToLabel(a);
  rightName.textContent = basenameToLabel(b);
  leftBtn.disabled = false;
  rightBtn.disabled = false;
}

// show bye
function showBye(a){
  leftImg.src = imgPath(a);
  leftImg.alt = basenameToLabel(a);
  leftName.textContent = basenameToLabel(a) + " (bye — auto-advance)";
  rightImg.src = "";
  rightName.textContent = "";
  leftBtn.disabled = true;
  rightBtn.disabled = true;

  // process bye automatically after short delay so user sees it
  setTimeout(() => {
    nextPool.push(a);
    history.push({type:'bye', data:{item:a}});
    pairQueue.shift();
    comparisonCount++;
    updatePoolUI();
  }, 700);
}

// handle choice
function choose(side){
  if(pairQueue.length === 0) return;
  const [a,b] = pairQueue[0];
  let winner, loser;
  if(side === 'left'){ winner = a; loser = b; } else { winner = b; loser = a; }

  // do different handling depending on mode
  if(mode === 'pairing'){
    // winner advances nextPool, loser recorded for sorting later
    nextPool.push(winner);
    roundLosersUnordered.push(loser);
    history.push({type:'pair', data:{winner, loser, round:roundNumber}});
    pairQueue.shift();
    comparisonCount++;
    updatePoolUI();
  } else if(mode === 'sortingLosers'){
    const currentItem = sortingState.currentItem;
    const ranked = sortingState.ranked;
    const idx = sortingState.compareIndex;
    let chosenIsCurrent = (side === 'left' && a===currentItem) || (side === 'right' && b===currentItem);
    
    if(chosenIsCurrent){
      // insert currentItem before ranked[idx]
      ranked.splice(idx, 0, currentItem);
      history.push({type:'insert-loser', data:{item:currentItem, pos:idx}});
      // clear currentItem
      sortingState.currentItem = null;
      // pop the comparison and continue
      pairQueue.shift();
      prepareNextSortingComparison();
    } else {
      // user prefers ranked[idx] over currentItem -> move compareIndex forward
      sortingState.compareIndex++;
      pairQueue.shift();
      prepareNextSortingComparison();
    }
    comparisonCount++;
    updatePoolUI();
  }
}

// finalize and show final ranking
function showFinal(){
  modeBadge.textContent = 'Mode: Finished';
  roundBadge.textContent = 'Complete';
  poolSize.textContent = 'Remaining: 0';
  // Build final ranking
  const ranking = [];
  if(champion) ranking.push(champion);
  ranking.push(...orderedLosersAllRounds);

  // If some items were never compared, add them
  const included = new Set(ranking);
  for(const it of initialPool){
    if(!included.has(it)) ranking.push(it);
  }

  // Show ranking
  rankingList.innerHTML = '';
  finalArea.hidden = false;
  for(let i=0;i<ranking.length;i++){
    const fn = ranking[i];
    const label = basenameToLabel(fn);
    const item = document.createElement('div');
    item.className = 'rank-item';
    item.innerHTML = `<div style="flex:1"><strong>#${i+1} — ${label}</strong></div><div style="display:flex;align-items:center;gap:8px"><img src="${imgPath(fn)}" alt="${label}"><div style="width:56px;text-align:right;color:#9aa7b2">${fn}</div></div>`;
    rankingList.appendChild(item);
  }

  log("Tournament complete. Final ranking shown below.");
  // disable buttons
  leftBtn.disabled = rightBtn.disabled = true;
}

// logging
function log(txt){
  const t = document.createElement('div');
  t.textContent = txt;
  logArea.prepend(t);
}

// initialize tournament
function startTournament(){
  // reset all
  roundNumber = 1;
  currentPool = initialPool.slice();
  nextPool = [];
  roundLosersUnordered = [];
  orderedLosersAllRounds = [];
  comparisonCount = 0;
  totalComparisonsEstimate = 0;
  mode = 'pairing';
  pairQueue = buildPairQueueFor(currentPool);
  totalComparisonsEstimate = pairQueue.length;
  history = [];
  champion = null;
  finalArea.hidden = true;
  rankingList.innerHTML = '';
  leftBtn.disabled = false;
  rightBtn.disabled = false;
  roundBadge.textContent = 'Round: ' + roundNumber;
  modeBadge.textContent = 'Mode: Pairing';
  poolSize.textContent = 'Remaining: ' + pairQueue.length;
  logArea.innerHTML = '';
  log("Starting Round 1 with " + currentPool.length + " dupes.");
  updatePoolUI();
}

// undo last action (single step)
function undo(){
  if(history.length === 0){ log("Nothing to undo."); return; }
  const last = history.pop();
  
  if(last.type === 'pair'){
    const {winner, loser, round} = last.data;
    const idx = nextPool.lastIndexOf(winner);
    if(idx !== -1) nextPool.splice(idx,1);
    pairQueue.unshift([winner, loser]);
    comparisonCount = Math.max(0, comparisonCount-1);
    log(`Undid pair: ${basenameToLabel(winner)} / ${basenameToLabel(loser)}`);
    mode = 'pairing';
    updatePoolUI();
    return;
  } else if(last.type === 'insert-loser'){
    const {item, pos} = last.data;
    if(sortingState && sortingState.ranked){
      const idx = sortingState.ranked.indexOf(item);
      if(idx !== -1) sortingState.ranked.splice(idx,1);
    } else {
      const idx = orderedLosersAllRounds.indexOf(item);
      if(idx !== -1) orderedLosersAllRounds.splice(idx,1);
    }
    if(!sortingState) sortingState = {items:[], ranked:[]};
    sortingState.items.unshift(item);
    comparisonCount = Math.max(0, comparisonCount-1);
    log(`Undid insertion of ${basenameToLabel(item)} into loser ordering.`);
    mode = 'sortingLosers';
    updatePoolUI();
    return;
  } else if(last.type === 'bye'){
    const {item} = last.data;
    const idx = nextPool.lastIndexOf(item);
    if(idx !== -1) nextPool.splice(idx,1);
    pairQueue.unshift([item, null]);
    comparisonCount = Math.max(0, comparisonCount-1);
    log(`Undid bye for ${basenameToLabel(item)}.`);
    mode = 'pairing';
    updatePoolUI();
    return;
  } else {
    log("Cannot undo that action.");
  }
}

// wire buttons
leftBtn.addEventListener('click', ()=>choose('left'));
rightBtn.addEventListener('click', ()=>choose('right'));
restartBtn.addEventListener('click', ()=>{
  if(confirm("Restart the entire tournament? This clears progress.")) startTournament();
});
undoBtn.addEventListener('click', ()=>undo());

// keyboard shortcuts (ArrowLeft / ArrowRight)
document.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowLeft') leftBtn.click();
  if(e.key === 'ArrowRight') rightBtn.click();
});

// kick things off
startTournament();

</script>
</body>
</html>
